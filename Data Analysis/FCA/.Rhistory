gammai_1[i] = (1/nrow(Z)) * (sum(GMi^2)/L$values[1])
}
gammai_1
# 6
gammai_1 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_1[i] = (1/nrow(Z)) * GMi[i]/L$values[1]
}
gammai_1
# 6
gammai_1 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_1[i] = (1/nrow(Z)) * (GMi[i]^2/L$values[1])
}
gammai_1
gammai_2 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_2[i] = (1/nrow(Z)) * (GMi[i]^2/L$values[2])
}
gammai_2
Z.pca <- PCA(Gmi, graph = FALSE)
GMi
# 6
gammai_1 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_1[i] = (1/nrow(Z)) * (GMi1[i]^2/L$values[1])
}
gammai_1
gammai_2 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_2[i] = (1/nrow(Z)) * (GMi2[i]^2/L$values[2])
}
gammai_2
#6
fviz_contrib(Z.pca, choice = "ind", axes = 1:2)
#5
Z.pca <- PCA(Gmi, graph = FALSE)
install.packages("psych", dependencies = TRUE)
# 3
# 3.1
X = c(0, 1, 0, 1, 1, 0)
Y = c(0, 1, 1, 0, 1, 0)
arr <- array(c(X,Y), dim = c(6,2,1))
print(arr)
# Poids statistiques:
Poids <- 1 / length(X)
# Matrice diagonale D des poids des individus
D <- diag(Poids, length(X), length(X))
print(D)
# Moyenne:
X.mean <- mean(X)
Y.mean <- mean(Y)
Z <- data.frame(X, Y)
Z$X = Z$X - X.mean
Z$Y = Z$Y - Y.mean
print(Z)
A <- cov(Z)
print(A)
# 3.2
L <- eigen(as.matrix(A))
L$values
# For ease of use
var_X = A[1, 1]
var_y = A[2, 2]
covariance = A[1, 2]
lambda1 = L$values[1]
lambda2 = L$values[2]
trace <- var_x + var_y
sum <- lambda1 + lambda2
# For ease of use
var_x = A[1, 1]
var_y = A[2, 2]
covariance = A[1, 2]
lambda1 = L$values[1]
lambda2 = L$values[2]
trace <- var_x + var_y
sum <- lambda1 + lambda2
print(trace)
print(trace == sum)
if (trace == sum) {
print("Equal")
} else {
print("Not equal")
}
# 3
# 3.1
X = c(0, 1, 0, 1, 1, 0)
Y = c(0, 1, 1, 0, 1, 0)
arr <- array(c(X,Y), dim = c(6,2,1))
print(arr)
# Poids statistiques:
Poids <- 1 / length(X)
# Matrice diagonale D des poids des individus
D <- diag(Poids, length(X), length(X))
print(D)
# Moyenne:
X.mean <- mean(X)
Y.mean <- mean(Y)
Z <- data.frame(X, Y)
Z$X = Z$X - X.mean
Z$Y = Z$Y - Y.mean
print(Z)
A <- cov(Z)
print(A)
# 3.2
L <- eigen(as.matrix(A))
L$values
# For ease of use
var_x = A[1, 1]
var_y = A[2, 2]
covariance = A[1, 2]
lambda1 = L$values[1]
lambda2 = L$values[2]
trace <- var_x + var_y
sum <- lambda1 + lambda2
if (trace == sum) {
print("Equal")
} else {
print("Not equal")
}
det <- var_x * var_y - covariance * covariance * covariance
mult <- lambda1 * lambda2
if (det == mult) {
print("Equal")
} else {
print("Not equal")
}
# 3.3
c1 = 1/sqrt(((var_y) - lambda1)^2 + (covariance)^2)
c2 = 1/sqrt(((var_y) - lambda2)^2 + (covariance)^2)
u1 <- -c1 * c(var_y - lambda1, -covariance)
u2 <- -c2 * c(var_y - lambda2, -covariance)
u1
u2
L$vectors
# 3.4
u = cbind(u1,u2)
Is = t(u) %*% A %*% u
Is
L$values
# 3.5
Is1 = t(u1) %*% A %*% u1
Is2 = t(u2) %*% A %*% u2
It = A[1, 1] + A[2, 2]
print(It)
print(Is1 + Is2)
# 3.6
plot(Z, pch=19)
abline(a=0, b=u1[2]/u1[1], col="blue")
abline(a=0, b=u2[2]/u2[1], col="red")
# 3.7
total <- L$values[1] + L$values[2]
TI1 <- L$values[1] / total
TI2 <- L$values[2] / total
TI1
TI2
# 4
GMi1 <- rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
GMi1[i] = c(Z[i,1], Z[i,2]) %*% u1
}
GMi1
GMi2 <- rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
GMi2[i] = c(Z[i,1], Z[i,2]) %*% u2
}
GMi2
GMi = cbind(GMi1, GMi2)
# 5
Qi = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
Qi[i] = sum(GMi^2)/sum(Z^2)
}
Qi
# 6
gammai_1 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_1[i] = (1/nrow(Z)) * (GMi1[i]^2/L$values[1])
}
gammai_1
gammai_2 = rep(0, nrow(Z))
for (i in 1:nrow(Z)) {
gammai_2[i] = (1/nrow(Z)) * (GMi2[i]^2/L$values[2])
}
gammai_2
# TP
# Ce code prend une matrice de la forme p*n et fait les modifications necessaires
ACP_function <- function(matrice, norme) {
# Standardization
m_ce <- NULL
if (norme) {
for(i in 1:nrow(matrice)) {
m_ce <- rbind(m_ce,(matrice[i,] - mean(matrice[i,]))/(sd(matrice[i,])))
}
} else {
m_ce <- matrice - mean(matrice)
}
# Matrice de covariance
m_ce <- as.data.frame(t(m_ce))
m_cov <- cov(m_ce)
# Valeurs et vecteurs propres
vp <- eigen(m_cov)
vectorP <- vp$vectors
# ACP
m_ce_t <- t(m_ce)
var <- rep(0 , nrow(m_ce))
var <- t(vectorP) %*% m_ce_t
var <- as.data.frame(t(var))
print(var)
# Contributions
valeursP <- vp$values
percentage <- valeursP/(nrow(matrice)-1)
percentage <- round((percentage/sum(percentage))*100, 1)
return(var)
}
# Testing
df <-ACP_function(t(data), FALSE)
# Testing
data <- data.frame(X, Y)
df <- ACP_function(t(data), FALSE)
print("Taux d’inertie expliqué par le composante 1: " + TI1)
print(paste("Taux d’inertie expliqué par le composante 1:", TI1))
print(paste("Taux d’inertie expliqué par le composante 1:", TI1))
print(paste("Taux d’inertie expliqué par le composante 1:", TI2))
u1
print(paste("1ere composante:", u1))
print(paste("2eme composante:", u2))
knitr::opts_chunk$set(echo = TRUE)
#### 3D plot
mypersp <- persp(x = x1,y=x2,z=z.grid,zlab = "f")
source("./test_functions.R")
# function dimension
dim <- 2
# choose a function from test_functions.R file
fun <- quadratic
glob_xstar <- fun(xx = rep(0,dim),get_glob_xstar=TRUE) # note the way to retrieve glob_xstar
# upper and lower bounds
LB<-c(-5,-5)
UB<-c(5,5)
# start drawing the function (necessarily dim=2)
no.grid <- 100
x1 <- seq(LB[1], UB[1], length.out=no.grid)
x2 <- seq(LB[2], UB[2], length.out=no.grid)
x.grid <- expand.grid(x1, x2)
z <- apply(x.grid, 1, fun)
z.grid <- matrix(z, no.grid)
### 2D contour plot
contour(x1, x2, z.grid, nlevels=20, xlab="x1", ylab="x2")
points(x = glob_xstar[1],y=glob_xstar[2],pch=3,cex=1.5,col="green")
#### 3D plot
mypersp <- persp(x = x1,y=x2,z=z.grid,zlab = "f")
points(x = trans3d(glob_xstar[1],glob_xstar[2],fun(glob_xstar),pmat=mypersp), pch=3,cex=1.5,col="green")
## Below is the nicer interactive 3D RGL version
library("rgl")
warnings()
install.packages(rgl)
install.packages('rgl')
install.packages('sass')
install.packages("rmarkdown", dependencies=TRUE, INSTALL_opts = c('--no-lock'))
knitr::opts_chunk$set(echo = TRUE)
source("./test_functions.R")
# function dimension
dim <- 2
# choose a function from test_functions.R file
fun <- quadratic
glob_xstar <- fun(xx = rep(0,dim),get_glob_xstar=TRUE) # note the way to retrieve glob_xstar
# upper and lower bounds
LB<-c(-5,-5)
UB<-c(5,5)
# start drawing the function (necessarily dim=2)
no.grid <- 100
x1 <- seq(LB[1], UB[1], length.out=no.grid)
x2 <- seq(LB[2], UB[2], length.out=no.grid)
x.grid <- expand.grid(x1, x2)
z <- apply(x.grid, 1, fun)
z.grid <- matrix(z, no.grid)
### 2D contour plot
contour(x1, x2, z.grid, nlevels=20, xlab="x1", ylab="x2")
points(x = glob_xstar[1],y=glob_xstar[2],pch=3,cex=1.5,col="green")
#### 3D plot
mypersp <- persp(x = x1,y=x2,z=z.grid,zlab = "f")
points(x = trans3d(glob_xstar[1],glob_xstar[2],fun(glob_xstar),pmat=mypersp), pch=3,cex=1.5,col="green")
## Below is the nicer interactive 3D RGL version
library("rgl")
open3d()
surface3d(x1, x2, z.grid, col= "lightblue")
points3d(glob_xstar[1], glob_xstar[2], fun(glob_xstar), pch=19, col="green", size=10)
title3d("a 2D function", col="blue", font=4)
decorate3d()
aspect3d(1, 1, 1)
#
library("readxl")
# Read data from excel
X <- read_excel("TP_AFC_majeur1718_travail.xlsx", na = " ")
setwd("~/Uni/Saint-Etiennes/Semester 7/Data Science/UP2/Analyse des données/TP-AFC")
library("readxl")
# Read data from excel
X <- read_excel("TP_AFC_majeur1718_travail.xlsx", na = " ")
X <- as.data.frame(X[, 2:3])
X <- na.omit(X)
# Add column names
V0 <- with(X, table(Sexe, Fonction))
rownames(V0) <- c("Non répondu", "H", "F")
colnames(V0) <- c(
"Non répondu", "Administratif", "Technicien (OS)",
"Ingénieur", "Technicien supérieur", "Direction",
"Contractuel S1", "Contractuel S2"
)
k <- 248
V <- V0 / k
print(V)
I <- length(unique(X[, 1]))
J <- length(unique(X[, 2]))
Dn <- diag(I)
rownames(Dn) <- c("Non répondu", "H", "F")
colnames(Dn) <- c("Non répondu", "H", "F")
Dp <- diag(J)
rownames(Dp) <- c(
"Non répondu", "Administratif", "Technicien (OS)",
"Ingénieur", "Technicien supérieur", "Direction",
"Contractuel S1", "Contractuel S2"
)
colnames(Dp) <- c(
"Non répondu", "Administratif", "Technicien (OS)",
"Ingénieur", "Technicien supérieur", "Direction",
"Contractuel S1", "Contractuel S2"
)
for (i in 1:I) {
S <- 0
for (j in 1:J) {
S <- S + V[i, j]
}
Dn[i, i] <- S
}
for (j in 1:J) {
S <- 0
for (i in 1:I) {
S <- S + V[i, j]
}
Dp[j, j] <- S
}
print(Dn)
print(Dp)
line_profiles <- solve(Dn) %*% V
print(line_profiles)
column_profiles <- solve(Dp) %*% t(V)
print(column_profiles)
S <- t(V) %*% line_profiles %*% solve(Dp)
A <- sqrt(solve(Dp)) %*% t(V) %*% line_profiles %*% sqrt(solve(Dp))
print(A)
decomp1 <- eigen(A)
eigen_values1 <- decomp1$values
eigen_vectors1 <- decomp1$vectors
print(eigen_values1)
print(eigen_vectors1)
u1 <- sqrt(Dp) %*% eigen_vectors1[, 1]
u2 <- sqrt(Dp) %*% eigen_vectors1[, 2]
C1 <- V %*% u1
C2 <- V %*% u2
plot(C1, C2, type = "p", xlim = c(-0.15, 0.05), ylim = c(-0.1, 0.1), col = "blue")
text(C1, C2, rownames(V), cex = 0.7, pos = 3, col = "blue")
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
T <- V %*% column_profiles %*% solve(Dn)
A2 <- sqrt(solve(Dn)) %*% V %*% column_profiles %*% sqrt(solve(Dn))
print(A2)
decomp2 <- eigen(A2)
eigen_values2 <- decomp2$values
eigen_vectors2 <- decomp2$vectors
print(eigen_values2)
print(eigen_vectors2)
u1_2 <- sqrt(Dn) %*% eigen_vectors2[, 1]
u2_2 <- sqrt(Dn) %*% eigen_vectors2[, 2]
C1_2 <- t(V) %*% u1_2
C2_2 <- t(V) %*% u2_2
plot(C1_2, C2_2, type = "p", xlim = c(-0.15, 0.05), ylim = c(-0.1, 0.1), col = "blue")
text(C1_2, C2_2, colnames(V), cex = 0.7, pos = 3, col = "blue")
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
# All points in the same plot
plot(C1, C2, pch = 24, cex = 1, col = "blue", lwd = 2, xlim = c(-0.15, 0.05), ylim = c(-0.1, 0.1))
text(C1, C2, rownames(V), cex = 0.75, col = "blue", pos = 3)
points(C1_2, C2_2, pch = 25, cex = 1, col = "red", lwd = 2)
text(C1_2, C2_2, colnames(V), cex = 0.75, col = "red", pos = 1)
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
# Nouvelles coordonnées dans Rp
co_lignes2 <- V %*% sqrt(Dp) %*% eigen_vectors1
# Nouvelles coordonnées dans Rn
co_colonnes2 <- t(V) %*% sqrt(Dn) %*% eigen_vectors2
quality <- function(n, i, k) {
A <- sum((n[i, ]^2))
B <- sum((n[i, 1:k]^2))
return(B / A)
}
# Qualité des projections sur Rp
quality1 <- rep(0, 3)
for (i in 1:7) {
quality1[i] <- quality(co_lignes2, i, 2)
}
library("readxl")
# Read data from excel
X <- read_excel("TP_AFC_majeur1718_travail.xlsx", na = " ")
X <- as.data.frame(X[, 2:3])
X <- na.omit(X)
# Add column names
V0 <- with(X, table(Sexe, Fonction))
rownames(V0) <- c("Non répondu", "H", "F")
colnames(V0) <- c(
"Non répondu", "Administratif", "Technicien (OS)",
"Ingénieur", "Technicien supérieur", "Direction",
"Contractuel S1", "Contractuel S2"
)
k <- 248
V <- V0 / k
print(V)
I <- length(unique(X[, 1]))
J <- length(unique(X[, 2]))
Dn <- diag(I)
rownames(Dn) <- c("Non répondu", "H", "F")
colnames(Dn) <- c("Non répondu", "H", "F")
Dp <- diag(J)
rownames(Dp) <- c(
"Non répondu", "Administratif", "Technicien (OS)",
"Ingénieur", "Technicien supérieur", "Direction",
"Contractuel S1", "Contractuel S2"
)
colnames(Dp) <- c(
"Non répondu", "Administratif", "Technicien (OS)",
"Ingénieur", "Technicien supérieur", "Direction",
"Contractuel S1", "Contractuel S2"
)
for (i in 1:I) {
S <- 0
for (j in 1:J) {
S <- S + V[i, j]
}
Dn[i, i] <- S
}
for (j in 1:J) {
S <- 0
for (i in 1:I) {
S <- S + V[i, j]
}
Dp[j, j] <- S
}
print(Dn)
print(Dp)
line_profiles <- solve(Dn) %*% V
print(line_profiles)
column_profiles <- solve(Dp) %*% t(V)
print(column_profiles)
S <- t(V) %*% line_profiles %*% solve(Dp)
A <- sqrt(solve(Dp)) %*% t(V) %*% line_profiles %*% sqrt(solve(Dp))
print(A)
decomp1 <- eigen(A)
eigen_values1 <- decomp1$values
eigen_vectors1 <- decomp1$vectors
print(eigen_values1)
print(eigen_vectors1)
u1 <- sqrt(Dp) %*% eigen_vectors1[, 1]
u2 <- sqrt(Dp) %*% eigen_vectors1[, 2]
C1 <- V %*% u1
C2 <- V %*% u2
plot(C1, C2, type = "p", xlim = c(-0.15, 0.05), ylim = c(-0.1, 0.1), col = "blue")
text(C1, C2, rownames(V), cex = 0.7, pos = 3, col = "blue")
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
T <- V %*% column_profiles %*% solve(Dn)
A2 <- sqrt(solve(Dn)) %*% V %*% column_profiles %*% sqrt(solve(Dn))
print(A2)
decomp2 <- eigen(A2)
eigen_values2 <- decomp2$values
eigen_vectors2 <- decomp2$vectors
print(eigen_values2)
print(eigen_vectors2)
u1_2 <- sqrt(Dn) %*% eigen_vectors2[, 1]
u2_2 <- sqrt(Dn) %*% eigen_vectors2[, 2]
C1_2 <- t(V) %*% u1_2
C2_2 <- t(V) %*% u2_2
plot(C1_2, C2_2, type = "p", xlim = c(-0.15, 0.05), ylim = c(-0.1, 0.1), col = "blue")
text(C1_2, C2_2, colnames(V), cex = 0.7, pos = 3, col = "blue")
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
# All points in the same plot
plot(C1, C2, pch = 24, cex = 1, col = "blue", lwd = 2, xlim = c(-0.15, 0.05), ylim = c(-0.1, 0.1))
text(C1, C2, rownames(V), cex = 0.75, col = "blue", pos = 3)
points(C1_2, C2_2, pch = 25, cex = 1, col = "red", lwd = 2)
text(C1_2, C2_2, colnames(V), cex = 0.75, col = "red", pos = 1)
abline(h = 0, col = "gray")
abline(v = 0, col = "gray")
# Nouvelles coordonnées dans Rp
co_lignes2 <- V %*% sqrt(Dp) %*% eigen_vectors1
# Nouvelles coordonnées dans Rn
co_colonnes2 <- t(V) %*% sqrt(Dn) %*% eigen_vectors2
quality <- function(n, i, k) {
A <- sum((n[i, ]^2))
B <- sum((n[i, 1:k]^2))
return(B / A)
}
# Qualité des projections sur Rp
quality1 <- rep(0, 3)
for (i in 1:3) {
quality1[i] <- quality(co_lignes2, i, 2)
}
# Qualité des projections sur Rp
quality2 <- rep(0, 7)
for (i in 1:7) {
quality2[i] <- quality(co_colonnes2, i, 2)
}
print(quality1)
print(quality2)
